// This file is automatically generated. Do not edit it directly.
import { createClient } from "@supabase/supabase-js";
import type { Database } from "./types";

const SUPABASE_URL = "https://ehqlkafauehdpqzrdkia.supabase.co";
const SUPABASE_PUBLISHABLE_KEY =
  "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImVocWxrYWZhdWVoZHBxenJka2lhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDk3MzE2NTAsImV4cCI6MjA2NTMwNzY1MH0.b9QDfH7wjlYfwK1-_QhaaRcN1CWIuC3qoHcyh1NYoRU";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

// Validate configuration
if (!SUPABASE_URL || !SUPABASE_PUBLISHABLE_KEY) {
  console.error(
    "❌ Supabase configuration missing. Check SUPABASE_URL and SUPABASE_PUBLISHABLE_KEY",
  );
}

const originalClient = createClient<Database>(
  SUPABASE_URL,
  SUPABASE_PUBLISHABLE_KEY,
  {
    auth: {
      persistSession: true,
      autoRefreshToken: true,
      detectSessionInUrl: true,
      flowType: "pkce",
    },
    global: {
      headers: {
        "x-application-name": "FlickPick",
      },
      fetch: (input, init) => {
        // Add timeout and better error handling
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 15000); // 15 second timeout

        return fetch(input, {
          ...init,
          signal: controller.signal,
        })
          .finally(() => clearTimeout(timeoutId))
          .catch((error) => {
            if (error.name === "AbortError") {
              throw new Error(
                "Request timeout - check your internet connection",
              );
            }
            throw error;
          });
      },
    },
    realtime: {
      params: {
        eventsPerSecond: 2,
      },
    },
  },
);

// Create a wrapper that prevents database error logging
const PROBLEMATIC_TABLES = [
  "user_notifications",
  "notification_preferences",
  "push_subscriptions",
  "user_settings",
];

export const supabase = new Proxy(originalClient, {
  get(target, prop) {
    if (prop === "from") {
      return (tableName: string) => {
        const originalFrom = target.from(tableName);

        // If it's a problematic table, wrap to suppress errors
        if (PROBLEMATIC_TABLES.includes(tableName)) {
          return new Proxy(originalFrom, {
            get(fromTarget, fromProp) {
              const original = fromTarget[fromProp as keyof typeof fromTarget];
              if (typeof original === "function") {
                return function (...args: any[]) {
                  const result = original.apply(fromTarget, args);

                  // Wrap promises to handle 42P01 errors silently
                  if (result && typeof result.then === "function") {
                    return result.catch((error: any) => {
                      if (error && error.code === "42P01") {
                        // Return the error without logging
                        return { data: null, error };
                      }
                      throw error;
                    });
                  }

                  return result;
                };
              }
              return original;
            },
          });
        }

        return originalFrom;
      };
    }

    return target[prop as keyof typeof target];
  },
});

// Test connection on initialization
originalClient.auth.getSession().catch((error) => {
  if (
    !error.message?.includes("42P01") &&
    !error.message?.includes("does not exist")
  ) {
    console.warn("⚠️ Initial Supabase connection test failed:", error.message);
  }
});
