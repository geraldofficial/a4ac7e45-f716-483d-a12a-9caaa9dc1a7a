// This file is automatically generated. Do not edit it directly.
import { createClient } from "@supabase/supabase-js";
import type { Database } from "./types";

const SUPABASE_URL = "https://ehqlkafauehdpqzrdkia.supabase.co";
const SUPABASE_PUBLISHABLE_KEY =
  "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImVocWxrYWZhdWVoZHBxenJka2lhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDk3MzE2NTAsImV4cCI6MjA2NTMwNzY1MH0.b9QDfH7wjlYfwK1-_QhaaRcN1CWIuC3qoHcyh1NYoRU";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

// Validate configuration
if (!SUPABASE_URL || !SUPABASE_PUBLISHABLE_KEY) {
  console.error(
    "❌ Supabase configuration missing. Check SUPABASE_URL and SUPABASE_PUBLISHABLE_KEY",
  );
}

const originalClient = createClient<Database>(
  SUPABASE_URL,
  SUPABASE_PUBLISHABLE_KEY,
  {
    auth: {
      persistSession: true,
      autoRefreshToken: true,
      detectSessionInUrl: true,
      flowType: "pkce",
    },
    global: {
      headers: {
        "x-application-name": "FlickPick",
      },
    },
    realtime: {
      params: {
        eventsPerSecond: 2,
      },
    },
  },
);

// Create a wrapper that prevents database error logging
const PROBLEMATIC_TABLES = [
  "user_notifications",
  "notification_preferences",
  "push_subscriptions",
  "user_settings",
];

export const supabase = new Proxy(originalClient, {
  get(target, prop) {
    if (prop === "from") {
      return (tableName: string) => {
        const originalFrom = target.from(tableName);

        // If it's a problematic table, wrap to suppress errors
        if (PROBLEMATIC_TABLES.includes(tableName)) {
          return new Proxy(originalFrom, {
            get(fromTarget, fromProp) {
              const original = fromTarget[fromProp as keyof typeof fromTarget];
              if (typeof original === "function") {
                return function (...args: any[]) {
                  const result = original.apply(fromTarget, args);

                  // Wrap promises to handle 42P01 errors silently
                  if (result && typeof result.then === "function") {
                    return result.catch((error: any) => {
                      if (error && error.code === "42P01") {
                        // Return the error without logging
                        return { data: null, error };
                      }
                      throw error;
                    });
                  }

                  return result;
                };
              }
              return original;
            },
          });
        }

        return originalFrom;
      };
    }

    return target[prop as keyof typeof target];
  },
});

// Enhanced connection test and health check
let connectionHealthy = false;
let lastConnectionTest = 0;

const testConnection = async () => {
  const now = Date.now();
  // Only test connection every 30 seconds to avoid spam
  if (now - lastConnectionTest < 30000 && connectionHealthy) {
    return connectionHealthy;
  }

  lastConnectionTest = now;

  try {
    // Simple health check
    const { error } = await originalClient.auth.getSession();

    if (!error) {
      connectionHealthy = true;
      console.log("✅ Supabase connection healthy");
    } else if (
      error.message?.includes("42P01") ||
      error.message?.includes("does not exist")
    ) {
      // These are expected schema errors, not connection issues
      connectionHealthy = true;
    } else {
      connectionHealthy = false;
      console.warn("⚠️ Supabase connection issue:", error.message);
    }
  } catch (error: any) {
    connectionHealthy = false;
    console.warn("⚠️ Supabase connection test failed:", error.message);
  }

  return connectionHealthy;
};

// Test connection on initialization
testConnection();

// Export connection health checker
export { testConnection };
